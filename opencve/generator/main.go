//go:build generate
// +build generate

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"
)

// TODO: Pagination for everything
var (
	fEndpoint    = flag.String("endpoint", "", "endpoint to generate code for")
	fAPIEndpoint = flag.String("api-endpoint", "", "endpoint of the API endpoint, defaults endpoint")
	fNoInterface = flag.Bool("no-interface", false, "disable generation of interface")
	fFilter      = flag.Bool("filter", false, "enable filtering")
)

func Plural(s string) string {
	if strings.HasSuffix(s, "ss") {
		return s + "es"
	} else if strings.HasSuffix(s, "y") {
		return s[:len(s)-1] + "ies"
	} else if strings.HasSuffix(s, "s") {
		return s
	} else {
		return s + "s"
	}
}

func Export(s string) string {
	if s == "cve" || s == "cwe" {
		return strings.ToUpper(s)
	}
	return strings.Title(s)
}

func StructTag(s string) string {
	return fmt.Sprintf("`json:\"%s\"`", s)
}

func main() {
	log.SetFlags(0)
	flag.Usage = func() {
		log.Println("Usage:")
		log.Println("\tgenerate", "<endpoint>")
		log.Println("Flags:")
		flag.PrintDefaults()
		log.Println("Example:")
		log.Fatalln("\tgenerate", "locations")
	}
	flag.Parse()
	if len(flag.Args()) != 1 {
		flag.Usage()
		os.Exit(1)
	}

	outputFilename := flag.Arg(0)

	fmt.Printf("Generating code for %s into file %s\n", *fEndpoint, outputFilename)

	t := template.New("").Funcs(template.FuncMap{
		"Plural":    Plural,
		"Export":    Export,
		"StructTag": StructTag,
	})

	if _, err := t.Parse(funcTemplate); err != nil {
		log.Fatalln("error parsing in template:", err)
	}

	args := map[string]interface{}{
		"APIEndpoint": *fAPIEndpoint,
		"Endpoint":    *fEndpoint,
		"Filter":      *fFilter,
		"NoInterface": *fNoInterface,
	}

	o := bytes.NewBuffer(nil)

	if err := t.Execute(o, args); err != nil {
		log.Fatalln("error in executing template:", err)
	}

	formatted, err := format.Source(o.Bytes())
	if err != nil {
		log.Fatalln("invalid generated go reported by formatter:", err)
	}

	if err := ioutil.WriteFile(outputFilename, formatted, 0644); err != nil {
		log.Fatalln("failed to write to file:", err)
	}
}

var funcTemplate = `package opencve

import (
	"context"
	"net/http"
	"net/url"
	"path"
)

const {{.Endpoint}}URL = "api/{{if .APIEndpoint}}{{ .APIEndpoint }}{{else}}{{ .Endpoint }}{{end}}"

{{ if not .NoInterface }}
// {{Export .Endpoint}}Service is an interface for interacting with the {{.Endpoint}} endpoints
type {{Export .Endpoint}}Service interface {
	List(context.Context{{ if .Filter }}, QueryFilter{{ end }}) (*{{Export .Endpoint}}List, error)
	Get(context.Context, string) (*{{Export .Endpoint}}Details, error)
}
{{ end }}

// {{Export .Endpoint }} is the interface between the HTTP client and the OpenCVE {{Plural .Endpoint}} endpoints
func (c *Client) {{Export .Endpoint}}() {{Export .Endpoint}}Service {
	return &{{Export .Endpoint}}Client{client: c}
}

// {{Export .Endpoint}}Client facilitates requests with the {{ .Endpoint }} endpoints
type {{Export .Endpoint}}Client struct {
	client *Client
}

// List fetches a list of {{Plural (Export .Endpoint) }}
func (c *{{Export .Endpoint}}Client) List(ctx context.Context{{ if .Filter }}, filter QueryFilter{{ end }}) (*{{Export .Endpoint}}List, error) {
	url := &url.URL{
		Scheme: "https",
		Host:   c.client.apiURL,
		Path:   {{.Endpoint}}URL,
	}

	{{ if .Filter }}
	if filter != nil {
		url.RawQuery = filter.QueryString()
	}
	{{ end }}

	res := &{{Export .Endpoint}}List{}
	if err := c.req(ctx, url, res); err != nil {
		return nil, err
	}

	return res, nil
}

// Get retrieves a specific {{Export .Endpoint}}
func (c *{{Export .Endpoint}}Client) Get(ctx context.Context, ID string) (*{{Export .Endpoint}}Details, error) {
	url := &url.URL{
		Scheme: "https",
		Host:   c.client.apiURL,
		Path:   path.Join({{.Endpoint}}URL, ID),
	}


	res := &{{Export .Endpoint}}Details{}
	if err := c.req(ctx, url, res); err != nil {
		return nil, err
	}

	return res, nil
}

func (c *{{Export .Endpoint}}Client) req(ctx context.Context, u *url.URL, dest interface{}) error {

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, u.String(), nil)
	if err != nil {
		return err
	}

	_, err = c.client.makeRequest(req, dest)
	if err != nil {
		return err
	}

	return nil
}

`
